import { Hono } from 'hono';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '../convex/_generated/api';
import type { Env, HonoVariables } from './types';

const imagesApi = new Hono<{ Bindings: Env; Variables: HonoVariables }>();

// Generate and store an image
imagesApi.post('/', async (c) => {
  const user = c.get('user');
  if (!user) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  try {
    const data = await c.req.json();
    const { prompt, model = "@cf/black-forest-labs/flux-1-schnell", steps = 4, seed } = data;

    if (!prompt) {
      return c.json({ error: 'Prompt is required' }, 400);
    }


    // Check environment bindings
    if (!c.env.AI) {
      console.error('âŒ AI binding not found');
      return c.json({ error: 'AI service not available' }, 500);
    }

    if (!c.env.convex_cf_workers_images_test) {
      console.error('âŒ R2 bucket binding not found');
      return c.json({ error: 'Storage service not available' }, 500);
    }

    if (!c.env.CONVEX_URL) {
      console.error('âŒ CONVEX_URL not found');
      return c.json({ error: 'Database service not configured' }, 500);
    }

    let imageBuffer;
    let base64Image;

    // Determine which AI service to use based on model
    if (model.startsWith('fal-ai/')) {
      // Use FAL AI for Pro models
      if (!c.env.FAL_KEY) {
        console.error('âŒ FAL_KEY not found');
        return c.json({ error: 'FAL AI service not configured' }, 500);
      }

      console.log('ðŸŽ¨ Using FAL AI for model:', model);
      
      try {
        const falResponse = await fetch('https://fal.run/' + model, {
          method: 'POST',
          headers: {
            'Authorization': `Key ${c.env.FAL_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            prompt,
            // seed: seed || Math.floor(Math.random() * 4294967295),
            enable_safety_checker: false,
            sync_mode: true,
            num_inference_steps: 20,
            guidance_scale: 2.5,
          }),
        });

        if (!falResponse.ok) {
          const errorText = await falResponse.text();
          console.error('âŒ FAL AI error:', errorText);
          return c.json({ error: 'FAL AI generation failed' }, 500);
        }

        const falResult = await falResponse.json() as any;
        // console.log('âœ… FAL AI response:', falResult);

        // Extract image data from FAL response
        if (falResult.images && falResult.images.length > 0) {
          const imageDataUri = falResult.images[0].url;
          
          // Check if it's a data URI (base64)
          if (imageDataUri.startsWith('data:image/')) {
            // Extract base64 data from data URI
            const base64Data = imageDataUri.split(',')[1];
            base64Image = base64Data;
            imageBuffer = Buffer.from(base64Data, 'base64');
            console.log('âœ… Extracted base64 data from FAL AI data URI');
          } else {
            // Fallback: download from URL (in case it's still a remote URL)
            const imageResponse = await fetch(imageDataUri);
            if (!imageResponse.ok) {
              throw new Error('Failed to download image from FAL');
            }
            
            imageBuffer = await imageResponse.arrayBuffer();
            base64Image = Buffer.from(imageBuffer).toString('base64');
            console.log('âœ… Downloaded image from FAL AI URL');
          }
        } else {
          console.error('âŒ No images in FAL response:', falResult);
          return c.json({ error: 'No images generated by FAL AI' }, 500);
        }
      } catch (error) {
        console.error('âŒ FAL AI error:', error);
        return c.json({ error: 'Failed to generate image with FAL AI', details: error.message }, 500);
      }
    } else {
      // Use Workers AI for default models
      console.log('ðŸ¤– Using Workers AI for model:', model);
      
      const result = await c.env.AI.run(model, {
        prompt,
        num_steps: steps,
        seed: seed || Math.floor(Math.random() * 4294967295),
      });
      console.log('âœ… Workers AI raw response type:', typeof result, result.constructor.name);

      // Handle different response formats from Workers AI
      if (result instanceof ReadableStream) {
        const response = new Response(result);
        imageBuffer = await response.arrayBuffer();
        base64Image = Buffer.from(imageBuffer).toString('base64');
      } else if (result && result.image) {
        base64Image = result.image;
        imageBuffer = Buffer.from(result.image, 'base64');
      } else if (result && result.images && result.images.length > 0) {
        base64Image = result.images[0];
        imageBuffer = Buffer.from(result.images[0], 'base64');
      } else {
        console.error('âŒ Unexpected result format:', result);
        return c.json({ error: 'Failed to generate image - unexpected response format' }, 500);
      }
    }
    
    // Create unique filename
    const filename = `${user.id}-${Date.now()}.png`;
    
    // Store in R2
    await c.env.convex_cf_workers_images_test.put(filename, imageBuffer, {
      httpMetadata: {
        contentType: 'image/png',
      },
    });
    
    // Verify the file was actually stored
    try {
      const verification = await c.env.convex_cf_workers_images_test.head(filename);
    } catch (verifyError) {
      console.log('âŒ R2 verification failed:', verifyError.message);
    }

    // Create a public URL using R2 public domain
    const imageUrl = `https://pub-1d414b448981415486cf93fcfcaf636d.r2.dev/${filename}`;

    // Save directly to Convex from Hono API (more efficient)
    const convex = new ConvexHttpClient(c.env.CONVEX_URL);
    const finalSeed = seed || Math.floor(Math.random() * 4294967295);
    await convex.mutation(api.images.addImage, {
      imageUrl,
      prompt,
      model,
      seed: finalSeed,
      steps,
      userId: user.id,
    });

    return c.json({
      success: true,
      image: {
        url: imageUrl,
        prompt,
        model,
        steps,
        seed: finalSeed,
        // Include base64 for immediate display
        base64: `data:image/png;base64,${base64Image}`,
      }
    });
  } catch (error) {
    return c.json({ 
      error: 'Failed to generate image', 
      details: error.message,
      type: error.constructor.name
    }, 500);
  }
});

// Delete an image by ID
imagesApi.delete('/:imageId', async (c) => {
  const user = c.get('user');
  if (!user) {
    return c.json({ error: 'Unauthorized' }, 401);
  }

  try {
    const imageId = c.req.param('imageId');

    if (!c.env.CONVEX_URL) {
      console.error('âŒ CONVEX_URL not found');
      return c.json({ error: 'Database service not configured' }, 500);
    }

    // First, get the image data from Convex to find the filename
    const convex = new ConvexHttpClient(c.env.CONVEX_URL);
    
    // Get the image record to extract filename from URL
    const images = await convex.query(api.images.getImages, { userId: user.id });
    const imageToDelete = images.find((img: any) => img._id === imageId);
    
    if (!imageToDelete) {
      console.error('âŒ Image not found for user');
      return c.json({ error: 'Image not found' }, 404);
    }

    // Extract filename from URL (last part after the last slash)
    const filename = imageToDelete.imageUrl.split('/').pop();

    // Delete from R2 first
    if (filename && c.env.convex_cf_workers_images_test) {
      await c.env.convex_cf_workers_images_test.delete(filename);
    }

    // Delete from Convex
    await convex.mutation(api.images.deleteImage, { imageId: imageId as any });

    return c.json({ success: true });
  } catch (error) {
    console.error('âŒ Error deleting image:', error);
    return c.json({ 
      error: 'Failed to delete image', 
      details: error.message 
    }, 500);
  }
});

// Get an image by filename (R2 object)
imagesApi.get('/:filename', async (c) => {
  const filename = c.req.param('filename');
  try {
    const object = await c.env.convex_cf_workers_images_test.get(filename);
    
    if (!object) {
      return c.json({ error: 'Image not found' }, 404);
    }
    
    const headers = new Headers();
    object.writeHttpMetadata(headers);
    headers.set('etag', object.httpEtag);
    
    return new Response(object.body, {
      headers,
    });
  } catch (error) {
    console.error('Error retrieving image:', error);
    return c.json({ error: 'Failed to retrieve image' }, 500);
  }
});

export default imagesApi;
